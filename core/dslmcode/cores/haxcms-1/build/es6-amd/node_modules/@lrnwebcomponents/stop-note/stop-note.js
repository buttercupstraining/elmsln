define(["exports", "meta", "../../lit-element/lit-element.js", "../schema-behaviors/schema-behaviors.js", "../utils/lib/remoteLinkBehavior.js", "../simple-icon/lib/simple-iconset.js", "../simple-icon/simple-icon.js"], function (_exports, meta, _litElement, _schemaBehaviors, _remoteLinkBehavior, _simpleIconset, _simpleIcon) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.StopNote = void 0;
  meta = babelHelpers.interopRequireWildcard(meta);

  // register the iconset
  _simpleIconset.SimpleIconsetStore.registerIconset("stopnoteicons", `${(0, _simpleIconset.pathResolver)(meta.url)}lib/svgs/stopnoteicons/`);

  const iconObj = {
    "stopnoteicons:stop-icon": "Stop",
    "stopnoteicons:warning-icon": "Warning",
    "stopnoteicons:confirm-icon": "Confirmation",
    "stopnoteicons:book-icon": "Notice"
  };
  /**
   * `stop-note`
   * `A note that directs people to an action item of different warning levels`
   * @demo demo/index.html
   * @element stop-note
   */

  class StopNote extends (0, _remoteLinkBehavior.remoteLinkBehavior)((0, _schemaBehaviors.SchemaBehaviors)(_litElement.LitElement)) {
    /**
     * LitElement constructable styles enhancement
     */
    static get styles() {
      return [(0, _litElement.css)`
        :host {
          display: block;
          width: auto;
          --background-color: #f7f7f7;
          --accent-color: #d32f2f;
          margin-bottom: 20px;
        }

        simple-icon {
          --simple-icon-height: 100px;
          --simple-icon-width: 100px;
        }

        :host([icon="stopnoteicons:stop-icon"]) {
          --accent-color: #d8261c;
        }

        :host([icon="stopnoteicons:warning-icon"]) {
          --accent-color: #ffeb3b;
        }

        :host([icon="stopnoteicons:confirm-icon"]) {
          --accent-color: #81c784;
        }

        :host([icon="stopnoteicons:book-icon"]) {
          --accent-color: #21a3db;
        }

        .container {
          display: flex;
          width: auto;
        }

        .message_wrap {
          border-right: 7px solid var(--accent-color);
          padding: 10px 25px;
          flex: 1 1 auto;
          background-color: var(--background-color);
        }

        .main_message {
          font-size: 32px;
          margin-top: 10px;
        }

        .secondary_message {
          margin-top: 5px;
          font-size: 19.2px;
          float: left;
        }

        .link a {
          margin-top: 5px;
          font-size: 19.2px;
          float: left;
          clear: left;
          text-decoration: none;
          color: #2196f3;
        }

        .link a:hover {
          color: #1976d2;
        }

        .svg {
          display: flex;
          justify-content: center;
        }

        .svg_wrap {
          background-color: var(--accent-color);
          padding: 5px;
          width: auto;
        }
      `];
    }

    render() {
      return (0, _litElement.html)`
      <div class="container">
        <div class="svg_wrap">
          <div class="svg">
            <simple-icon icon="${this.icon}" no-colorize></simple-icon>
          </div>
        </div>
        <div class="message_wrap">
          <div class="main_message" id="title">${this.title}</div>
          <div class="secondary_message"><slot name="message"></slot></div>
          ${this.url ? (0, _litElement.html)`
                <div class="link">
                  <a href="${this.url}" id="link"> More Information &gt; </a>
                </div>
              ` : ``}
        </div>
      </div>
    `;
    }

    static get tag() {
      return "stop-note";
    }

    constructor() {
      super();
      this.url = null;
      this.title = "";
      this.icon = "stopnoteicons:stop-icon";
    }

    static get properties() {
      return {
        /**
         * Title Message
         */
        title: {
          type: String,
          reflect: true
        },

        /**
         * url to additional resources
         */
        url: {
          type: String
        },

        /**
         * Icon selected
         */
        icon: {
          type: String,
          reflect: true
        }
      };
    }

    updated(changedProperties) {
      if (super.updated) {
        super.updated(changedProperties);
      }

      changedProperties.forEach((oldValue, propName) => {
        if (propName == "url") {
          this.remoteLinkURL = this[propName];
        }
      });
    }

    firstUpdated(changedProperties) {
      if (super.firstUpdated) {
        super.firstUpdated(changedProperties);
      }

      this.remoteLinkTarget = this.shadowRoot.querySelector("#link");
    }
    /**
     * Implements haxHooks to tie into life-cycle if hax exists.
     */


    haxHooks() {
      return {
        activeElementChanged: "haxactiveElementChanged",
        inlineContextMenu: "haxinlineContextMenu"
      };
    }
    /**
     * double-check that we are set to inactivate click handlers
     * this is for when activated in a duplicate / adding new content state
     */


    haxactiveElementChanged(el, val) {
      // flag for HAX to not trigger active on changes
      let container = this.shadowRoot.querySelector("#title");
      let svgWrap = this.shadowRoot.querySelector(".svg_wrap");

      if (val) {
        svgWrap.addEventListener("click", this.haxtoggleIcon.bind(this));
        container.setAttribute("contenteditable", true);
      } else {
        svgWrap.removeEventListener("click", this.haxtoggleIcon.bind(this));
        container.removeAttribute("contenteditable");
        this.title = container.innerText;
      }

      return false;
    }

    haxinlineContextMenu(ceMenu) {
      ceMenu.ceButtons = [{
        icon: "image:style",
        callback: "haxtoggleIcon",
        label: "Toggle icon"
      }];
    }

    haxtoggleIcon(e) {
      const iconAry = Object.keys(iconObj);
      let icon = iconAry[0];

      if (iconAry.lastIndexOf(this.icon) != iconAry.length - 1) {
        icon = iconAry[iconAry.lastIndexOf(this.icon) + 1];
      }

      this.icon = icon;
      return true;
    }

    static get haxProperties() {
      return {
        canScale: true,
        canPosition: true,
        canEditSource: true,
        contentEditable: true,
        gizmo: {
          title: "Stop Note",
          description: "A message to alert readers to specific directions.",
          icon: "icons:report",
          color: "orange",
          groups: ["Education", "Content"],
          handles: [{
            type: "text",
            title: "label"
          }],
          meta: {
            author: "ELMS:LN"
          }
        },
        settings: {
          configure: [{
            property: "title",
            title: "Title",
            description: "Enter title for stop-note.",
            inputMethod: "textfield",
            required: true
          }, {
            property: "url",
            title: "URL",
            description: "Enter an external url.",
            inputMethod: "haxupload",
            required: true
          }, {
            property: "icon",
            title: "Action Icon",
            description: "Icon used for stop-note",
            inputMethod: "select",
            options: iconObj
          }],
          advanced: []
        },
        saveOptions: {
          unsetAttributes: ["colors"]
        },
        demoSchema: [{
          tag: "stop-note",
          properties: {
            title: "Hold up there"
          },
          content: '<p slot="message"><strong>Read these important things!</strong>\n</p>\n'
        }, {
          tag: "stop-note",
          properties: {
            title: "Warning",
            icon: "stopnoteicons:warning-icon"
          },
          content: '<p slot="message">You can write any warning message you want here.</p>\n'
        }]
      };
    }

  }

  _exports.StopNote = StopNote;
  window.customElements.define(StopNote.tag, StopNote);
});