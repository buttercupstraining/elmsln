define(["exports", "../../../lit-element/lit-element.js", "../../simple-filter/simple-filter.js", "../../utils/utils.js", "./hax-store.js", "../../../mobx/dist/mobx.esm.js", "../../simple-fields/lib/simple-fields-field.js"], function (_exports, _litElement, _simpleFilter, _utils, _haxStore, _mobxEsm, _simpleFieldsField) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HaxGizmoBrowser = void 0;

  /**
   * `hax-gizmo-browser`
   * `Browse a list of gizmos. This provides a listing of custom elements for people to search and select based on what have been defined as gizmos for users to select.`
   * @microcopy - the mental model for this element
   * - gizmo - silly name for the general public when talking about custom elements and what it provides in the end.
   */
  class HaxGizmoBrowser extends (0, _simpleFilter.SimpleFilterMixin)(_litElement.LitElement) {
    static get styles() {
      return [(0, _litElement.css)`
        :host {
          display: block;
        }
        .toolbar-inner {
          padding: 0;
          position: sticky;
          background-color: white;
          width: 100%;
          top: 0;
          z-index: 1;
        }
        .item-wrapper {
          text-align: center;
        }
      `];
    }

    constructor() {
      super();
      this.where = "title";
    }

    render() {
      return (0, _litElement.html)`
      <div class="toolbar-inner">
        <simple-fields-field
          id="inputfilter"
          @value-changed="${this.inputfilterChanged}"
          aria-controls="filter"
          label="Filter"
          type="text"
          auto-validate=""
        ></simple-fields-field>
      </div>
      <div class="item-wrapper">
        ${this.filtered.map((gizmo, i) => (0, _litElement.html)`
            <hax-tray-button
              dark-bg
              voice-command="insert ${gizmo.title}"
              draggable="true"
              @dragstart="${this._dragStart}"
              @dragend="${this._dragEnd}"
              index="${i}"
              label="${gizmo.title}"
              event-name="insert-tag"
              event-data="${gizmo.tag}"
              data-demo-schema="true"
              icon="${gizmo.icon}"
              drag-color="${gizmo.color}"
            ></hax-tray-button>
          `)}
      </div>
    `;
    }

    static get tag() {
      return "hax-gizmo-browser";
    }
    /**
     * Drag start so we know what target to set
     */


    _dragStart(e) {
      // create the tag
      let schema = _haxStore.HAXStore.haxSchemaFromTag(e.target.eventData);

      var target;

      if (schema.gizmo.tag && schema.demoSchema && schema.demoSchema[0]) {
        target = (0, _utils.haxElementToNode)(schema.demoSchema[0]);
      } else {
        target = document.createElement(e.target.eventData);
      }

      _haxStore.HAXStore.__dragTarget = target;

      if (e.dataTransfer) {
        this.crt = target.cloneNode(true);

        if (schema.gizmo.tag && schema.demoSchema && schema.demoSchema[0]) {
          this.crt.style.width = "200px";
          this.crt.style.height = "200px";
        } else {
          this.crt.style.position = "absolute";
          this.crt.style.top = "-1000px";
          this.crt.style.right = "-1000px";
          this.crt.style.transform = "scale(0.25)";
        }

        this.crt.style.opacity = ".8";
        this.crt.style.backgroundColor = e.target.getAttribute("drag-color");
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.dropEffect = "move"; //document.body.appendChild(this.crt);

        e.dataTransfer.setDragImage(this.crt, 0, 0);
      }

      e.stopPropagation();
      e.stopImmediatePropagation();
    }
    /**
     * When we end dragging ensure we remove the mover class.
     */


    _dragEnd(e) {
      this.crt.remove();
    }

    inputfilterChanged(e) {
      this.like = e.target.value;
    }

    updated(changedProperties) {
      changedProperties.forEach((oldValue, propName) => {
        if (propName == "activeApp") {
          this._activeAppChanged(this[propName], oldValue);
        }

        if (propName == "filtered") {
          this.requestUpdate();
        }
      });
    }

    firstUpdated(changedProperties) {
      if (super.firstUpdated) {
        super.firstUpdated(changedProperties);
      }

      (0, _mobxEsm.autorun)(() => {
        this.resetList((0, _mobxEsm.toJS)(_haxStore.HAXStore.gizmoList));
      });
    }
    /**
     * Reset this browser.
     */


    resetList(list) {
      super.resetList(list);

      if (list) {
        this.items = [...list.filter((gizmo, i) => {
          // remove inline and hidden references
          if (gizmo && gizmo.meta && (gizmo.meta.inlineOnly || gizmo.meta.hidden)) {
            return false;
          }

          return true;
        })];
      }
    }

  }

  _exports.HaxGizmoBrowser = HaxGizmoBrowser;
  window.customElements.define(HaxGizmoBrowser.tag, HaxGizmoBrowser);
});